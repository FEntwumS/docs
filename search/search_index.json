{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FEntwumS Project Documenation - An Open-Source FPGA Development Environment \u00b6 This project focuses on the development of an intuitive, open-source development environment for FPGAs. The goal is to create comprehensive design tools with simulation and visualization capabilities for implementing digital circuits. These docs should help you get started and contribute to this project. Project Structure \u00b6 FEntwumS can be divided into three subprojects: FPGA Design Tools : Visualization and simulation features for digital circuit development. Graphical System Builder and Circuit Design Tool : A graphical design tool for creating custom SoC configurations. AI Accelerator : Development of tools and accelerators designed for efficient processing of AI algorithms. This GitHub organization focuses on the first two subprojects. They are implemented as multiple plugins for OneWare Studio , an open-source IDE for FPGA design. Read more about general OneWare (plugin) development in A Brief Introduction to OneWare Studio and its Plugins .","title":"Home"},{"location":"#fentwums-project-documenation-an-open-source-fpga-development-environment","text":"This project focuses on the development of an intuitive, open-source development environment for FPGAs. The goal is to create comprehensive design tools with simulation and visualization capabilities for implementing digital circuits. These docs should help you get started and contribute to this project.","title":"FEntwumS Project Documenation - An Open-Source FPGA Development Environment"},{"location":"#project-structure","text":"FEntwumS can be divided into three subprojects: FPGA Design Tools : Visualization and simulation features for digital circuit development. Graphical System Builder and Circuit Design Tool : A graphical design tool for creating custom SoC configurations. AI Accelerator : Development of tools and accelerators designed for efficient processing of AI algorithms. This GitHub organization focuses on the first two subprojects. They are implemented as multiple plugins for OneWare Studio , an open-source IDE for FPGA design. Read more about general OneWare (plugin) development in A Brief Introduction to OneWare Studio and its Plugins .","title":"Project Structure"},{"location":"about/","text":"About \u00b6 This documentation is written in .md and generated via mkdocs .","title":"About"},{"location":"about/#about","text":"This documentation is written in .md and generated via mkdocs .","title":"About"},{"location":"developer_guide/netlist_viewer/api_information/","text":"Backend API information for frontend developers \u00b6 Format of the layouted netlist \u00b6 The returned JSON document is formatted as ELK-JSON. The exact specification may be found in the ELK documentation . The following options are used in the generation of the document: omitZeroDimension \u2192 Whenever no dimension is specified for a given element, the receiving program should assume that it is 0 instead omitZeroPosition \u2192 Whenever no position is specified for a given element, the receiving program should assume that it is 0 instead shortLayoutOptionKeys \u2192 All layout options are shortened to reduce file size The document contains some, if not all the options described here in addition to the layout options included in ELK. Hash generation \u00b6 To uniquely identify the netlists on the backend server, the client must send an identifying hash alongside them. This hash is generated using the one_at_a_time hash function by Bob Jenkins. The hash is a 64 bit unsigned integer, where the upper 32 bits are the hashed absolute path of the netlist file, while the lower 32 bits are the hashed contents of the netlist file. Creating a graph representation of a given netlist \u00b6 /graphLocalFile \u00b6 Parameters: filename : The absolute path pointing to the netlist file hash : The hash that is to be usd for this file. This hash is generated as described here Notes: - This call only works when the file is located on the same system as the running backend executable. /graphRemoteFile \u00b6 Parameters: file : A multipart file, containing the netlist files' contents hash : The hash that is to be usd for this file. This hash is generated as described here Modifying or retreiving an existing graph \u00b6 The following calls only return results if the referenced netlist already exists on the backend server. /expandNode \u00b6 This call collapses the given cell, if it is expanded (its' children are visible) or vice-versa. Parameters: hash : The hash that is to be usd for this file. This hash is generated as described here nodepath : The path of the node that is to be collapsed or expanded. Can be found in the location-path option Notes: While cells have their location-path set, they can neither be expanded or collapsed, as they have no children This call forces a partial re-layout of the graph. Depending on the number of visible entities and cells, this may take a while. /get-current-graph \u00b6 Parameters: hash : The hash that is to be usd for this file. This hash is generated as described here Mapping signal names to yosys bitindices \u00b6 /get-net-information \u00b6 Parameters: hash : The hash that is to be usd for this file. This hash is generated as described here Notes: The JSON document is formatted as follows: { \"signals\": { \"<signalname>\": { \"scope\": \"<hdlname|scopename>\", \"bits\": [ <bitindex>, ... ] }, ... } }","title":"Backend API information"},{"location":"developer_guide/netlist_viewer/api_information/#backend-api-information-for-frontend-developers","text":"","title":"Backend API information for frontend developers"},{"location":"developer_guide/netlist_viewer/api_information/#format-of-the-layouted-netlist","text":"The returned JSON document is formatted as ELK-JSON. The exact specification may be found in the ELK documentation . The following options are used in the generation of the document: omitZeroDimension \u2192 Whenever no dimension is specified for a given element, the receiving program should assume that it is 0 instead omitZeroPosition \u2192 Whenever no position is specified for a given element, the receiving program should assume that it is 0 instead shortLayoutOptionKeys \u2192 All layout options are shortened to reduce file size The document contains some, if not all the options described here in addition to the layout options included in ELK.","title":"Format of the layouted netlist"},{"location":"developer_guide/netlist_viewer/api_information/#hash-generation","text":"To uniquely identify the netlists on the backend server, the client must send an identifying hash alongside them. This hash is generated using the one_at_a_time hash function by Bob Jenkins. The hash is a 64 bit unsigned integer, where the upper 32 bits are the hashed absolute path of the netlist file, while the lower 32 bits are the hashed contents of the netlist file.","title":"Hash generation"},{"location":"developer_guide/netlist_viewer/api_information/#creating-a-graph-representation-of-a-given-netlist","text":"","title":"Creating a graph representation of a given netlist"},{"location":"developer_guide/netlist_viewer/api_information/#graphlocalfile","text":"Parameters: filename : The absolute path pointing to the netlist file hash : The hash that is to be usd for this file. This hash is generated as described here Notes: - This call only works when the file is located on the same system as the running backend executable.","title":"/graphLocalFile"},{"location":"developer_guide/netlist_viewer/api_information/#graphremotefile","text":"Parameters: file : A multipart file, containing the netlist files' contents hash : The hash that is to be usd for this file. This hash is generated as described here","title":"/graphRemoteFile"},{"location":"developer_guide/netlist_viewer/api_information/#modifying-or-retreiving-an-existing-graph","text":"The following calls only return results if the referenced netlist already exists on the backend server.","title":"Modifying or retreiving an existing graph"},{"location":"developer_guide/netlist_viewer/api_information/#expandnode","text":"This call collapses the given cell, if it is expanded (its' children are visible) or vice-versa. Parameters: hash : The hash that is to be usd for this file. This hash is generated as described here nodepath : The path of the node that is to be collapsed or expanded. Can be found in the location-path option Notes: While cells have their location-path set, they can neither be expanded or collapsed, as they have no children This call forces a partial re-layout of the graph. Depending on the number of visible entities and cells, this may take a while.","title":"/expandNode"},{"location":"developer_guide/netlist_viewer/api_information/#get-current-graph","text":"Parameters: hash : The hash that is to be usd for this file. This hash is generated as described here","title":"/get-current-graph"},{"location":"developer_guide/netlist_viewer/api_information/#mapping-signal-names-to-yosys-bitindices","text":"","title":"Mapping signal names to yosys bitindices"},{"location":"developer_guide/netlist_viewer/api_information/#get-net-information","text":"Parameters: hash : The hash that is to be usd for this file. This hash is generated as described here Notes: The JSON document is formatted as follows: { \"signals\": { \"<signalname>\": { \"scope\": \"<hdlname|scopename>\", \"bits\": [ <bitindex>, ... ] }, ... } }","title":"/get-net-information"},{"location":"developer_guide/netlist_viewer/development_setup/","text":"Prerequisites \u00b6 To work on developing the netlist viewer, you need to have the following tools installed: JDK 21 or higher .net 9.0 maven 3.9 or higher (recommended) a Java IDE such as IntelliJ Idea (recommended) a C# IDE such as Jetbrains Rider Compiling OneWare Studio \u00b6 The official developer documentation for plugin development with for OneWare Studio can be found here . It is recommended to compile your own version of OneWare Studio for plugin development. Just clone the OneWare Studio source code from here . It may be necessary to check out a ceratin commit before you can start building OneWare Studio. Please check the readme for any such notices. Once you have completed the previous steps, you can start the compilation. Please first select the correct project to build (namely OneWare.Studio.Desktop ), then compile the project. From the base directory of your local git repo, you should now be able to find the OneWare Studio executable (eg OneWareStudio.exe ) under studio/OneWare.Studio.Desktop/bin/Debug/net9.0/[your target platform, eg win-x64]/ . Compiling the plugin \u00b6 In another directory, clone the plugin repository . To be able to directly run the plugin from Rider, add a new run configuration. For the Exe path , enter the directory of the OneWare Studio executable you previously compiled. For Program arguments , enter --modules ./ . And for the Working directory , enter [plugin git repo]/src/FEntwumS.NetlistViewer/bin/debug/net9.0 . If you followed all the instructions, running the configuration should open OneWare Studio with the FEntwumS netlist viewer plugin loaded. Plugin Development with multiple projects/plugins \u00b6 To load multiple plugins/DLLs simultaneously during development in OneWare: Compile each project into a common build folder. This folder holds the DLLs from all your compiled projects. In the above example project structure is: project-root/ \u251c\u2500\u2500 bin/Debug/net9.0/ # Common build folder for compiled plugins/DLLs \u251c\u2500\u2500 FEntwums.NetlistViewer.dll \u251c\u2500\u2500 WaveformInteractor.dll \u2514\u2500\u2500 ... \u251c\u2500\u2500 src/ # Source code for individual plugins \u2502 \u251c\u2500\u2500 FEntwums.NetlistViewer/ \u2502 \u2502 \u251c\u2500\u2500 src/ \u2502 \u2502 \u251c\u2500\u2500 FEntwumS.NetlistViewer.csproj \u2502 \u2502 \u251c\u2500\u2500 FEntwumSNetlistReaderFrontendModule.cs \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u251c\u2500\u2500 FEntwums.WaveformInteractor/ \u2502 \u2502 \u251c\u2500\u2500 src/ \u2502 \u2502 \u251c\u2500\u2500 FEntwumS.WaveformInteractor.csproj \u2502 \u2502 \u251c\u2500\u2500 FEntwumSWaveformInteractorModule.cs \u2502 \u2502 \u2514\u2500\u2500 ... Pass the ./bin/Debug/net9.0 folder as a parameter to the OneWare executable in your IDE's launch configuration: Compiling the backend \u00b6 If you want to work on the backend, please clone the respective git repo and follow the instructions here to compile your own version. If you want to test any changes you made, start the backend manually using java -jar fentwums-netlist-reader-server-[version number]-exec.jar in the fentwums-netlist-reader-server/target directory. The frontend plugin will automatically use the already running backend.","title":"Development setup"},{"location":"developer_guide/netlist_viewer/development_setup/#prerequisites","text":"To work on developing the netlist viewer, you need to have the following tools installed: JDK 21 or higher .net 9.0 maven 3.9 or higher (recommended) a Java IDE such as IntelliJ Idea (recommended) a C# IDE such as Jetbrains Rider","title":"Prerequisites"},{"location":"developer_guide/netlist_viewer/development_setup/#compiling-oneware-studio","text":"The official developer documentation for plugin development with for OneWare Studio can be found here . It is recommended to compile your own version of OneWare Studio for plugin development. Just clone the OneWare Studio source code from here . It may be necessary to check out a ceratin commit before you can start building OneWare Studio. Please check the readme for any such notices. Once you have completed the previous steps, you can start the compilation. Please first select the correct project to build (namely OneWare.Studio.Desktop ), then compile the project. From the base directory of your local git repo, you should now be able to find the OneWare Studio executable (eg OneWareStudio.exe ) under studio/OneWare.Studio.Desktop/bin/Debug/net9.0/[your target platform, eg win-x64]/ .","title":"Compiling OneWare Studio"},{"location":"developer_guide/netlist_viewer/development_setup/#compiling-the-plugin","text":"In another directory, clone the plugin repository . To be able to directly run the plugin from Rider, add a new run configuration. For the Exe path , enter the directory of the OneWare Studio executable you previously compiled. For Program arguments , enter --modules ./ . And for the Working directory , enter [plugin git repo]/src/FEntwumS.NetlistViewer/bin/debug/net9.0 . If you followed all the instructions, running the configuration should open OneWare Studio with the FEntwumS netlist viewer plugin loaded.","title":"Compiling the plugin"},{"location":"developer_guide/netlist_viewer/development_setup/#plugin-development-with-multiple-projectsplugins","text":"To load multiple plugins/DLLs simultaneously during development in OneWare: Compile each project into a common build folder. This folder holds the DLLs from all your compiled projects. In the above example project structure is: project-root/ \u251c\u2500\u2500 bin/Debug/net9.0/ # Common build folder for compiled plugins/DLLs \u251c\u2500\u2500 FEntwums.NetlistViewer.dll \u251c\u2500\u2500 WaveformInteractor.dll \u2514\u2500\u2500 ... \u251c\u2500\u2500 src/ # Source code for individual plugins \u2502 \u251c\u2500\u2500 FEntwums.NetlistViewer/ \u2502 \u2502 \u251c\u2500\u2500 src/ \u2502 \u2502 \u251c\u2500\u2500 FEntwumS.NetlistViewer.csproj \u2502 \u2502 \u251c\u2500\u2500 FEntwumSNetlistReaderFrontendModule.cs \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u251c\u2500\u2500 FEntwums.WaveformInteractor/ \u2502 \u2502 \u251c\u2500\u2500 src/ \u2502 \u2502 \u251c\u2500\u2500 FEntwumS.WaveformInteractor.csproj \u2502 \u2502 \u251c\u2500\u2500 FEntwumSWaveformInteractorModule.cs \u2502 \u2502 \u2514\u2500\u2500 ... Pass the ./bin/Debug/net9.0 folder as a parameter to the OneWare executable in your IDE's launch configuration:","title":"Plugin Development with multiple projects/plugins"},{"location":"developer_guide/netlist_viewer/development_setup/#compiling-the-backend","text":"If you want to work on the backend, please clone the respective git repo and follow the instructions here to compile your own version. If you want to test any changes you made, start the backend manually using java -jar fentwums-netlist-reader-server-[version number]-exec.jar in the fentwums-netlist-reader-server/target directory. The frontend plugin will automatically use the already running backend.","title":"Compiling the backend"},{"location":"developer_guide/netlist_viewer/extra_layout_options/","text":"Extra layout options \u00b6 The following options have been added to the standard set of ELK options. They contain additional metadata about the netlist that helps frontends interact with the backend.# de.thkoeln.fentwums.netlist.backend.signalname \u00b6 Shortened option key: signalname Type: String Intended use: Contains the name of the signal this edge belongs to Target: Edges de.thkoeln.fentwums.netlist.backend.signalindex \u00b6 Shortened option key: signalindex Type: Integer Intended use: Contains the bitindex of the signal this edge belongs to. It is globally unique within the netlist and is a positive integer greater than 1 Target: Edges de.thkoeln.fentwums.netlist.backend.cellname \u00b6 Shortened option key: cellname Type: String Intended use: Contains the name of the cell described by this node Target: Nodes de.thkoeln.fentwums.netlist.backend.celltype \u00b6 Shortened option key: celltype Type: String Intended use: Contains the type of the cell described by this node. Constant drivers are of type Constant driver . A list of the celltypes yosys is able to generate can be found here . Target: Nodes de.thkoeln.fentwums.netlist.backend.location-path \u00b6 Shortened option key: location-path Type: String Intended use: Contains the location of the cell or part of the signal described by this element inside the netlist hierarchy Targets: Nodes and Edges de.thkoeln.fentwums.netlist.backend.src-location \u00b6 Shortened option key: src-location Type: String Intended use: Contains the location of the HDL-Code that is represented (in part or completely) by this element. Contains the absolute file path as well as line and column numbers Targets: Nodes and Edges de.thkoeln.fentwums.netlist.backend.signalvalue \u00b6 Shortened option key: signalvalue Type: String Intended use: Contains the current value of the signal represented by this edge. Each character is the value of one of the contained bitindices. Target: Edges de.thkoeln.fentwums.netlist.backend.index-in-signal \u00b6 Shortened option key: index-in-signal Type: Integer Intended use: Contains the index of the signal described by this edge inside its containing signal (a vector). -1 if no containing signal exists Target: Edges de.thkoeln.fentwums.netlist.backend.signaltype \u00b6 Shortened option key: signaltype Type: String Value: One of CONSTANT , BUNDLED_CONSTANT , BUNDLED , SINGLE or UNDEFINED Intended use: Contains information about the type of signal represented by this edge Target: Edges de.thkoeln.fentwums.netlist.backend.port-group-name \u00b6 Shortened option key: port-group-name Type: String Intended use: Contains the group a port belongs to, e.g. D , Q , S ... Target: Ports de.thkoeln.fentwums.netlist.backend.font-size \u00b6 Shortened option key: font-size Type: double Intended use: The font size of the label this attribute is attached to Target: Labels de.thkoeln.fentwums.netlist.backend.not-connected \u00b6 Shortened option key: not-connected Type: boolean Intended use: Any port where this option is set to true does not have outgoing or incoming connections. The viewer can therefore use the value of this option to add additional symbols showing the connectedness of ports Target: Ports de.thkoeln.fentwums.netlist.backend.index-in-port-group \u00b6 Shortened option key: index-in-port-group Type: Integer Intended use: Contains the index of the port inside the port group it belongs to Target: Edges de.thkoeln.fentwums.netlist.backend.canonical-index-in-port-group \u00b6 Shortened option key: canonical-index-in-port-group Type: Integer Intended use: Contains the index of the port as described by the HDL sources. Can therefore be negative and may not start at index 0 Target: Ports de.thkoeln.fentwums.netlist.backend.canonical-bundle-lower-index-in-port-group \u00b6 Shortened option key: canonical-bundle-lower-index-in-port-group Type: Integer Intended use: Contains the lowest contained canonical index of the bundle contained in this port. The range is continous between lower and upper limit Target: Ports de.thkoeln.fentwums.netlist.backend.canonical-bundle-upper-index-in-port-group \u00b6 Shortened option key: canonical-bundle-upper-index-in-port-group Type: Integer Intended use: Contains the highest contained canonical index of the bundle contained in this port Target: Ports de.thkoeln.fentwums.netlist.backend.port-type \u00b6 Short option key: port-type Type: String Value: One of SIGNAL_SINGLE , SIGNAL_MULTIPLE , CONSTANT_SINGLE or CONSTANT_MULTIPLE Inteded use: Describes whether a port contains only one or multiple signals and whether they are constant or not Target: Ports de.thkoeln.fentwums.netlist.backend.port-direction \u00b6 Shortened option key: port-direction Type: String Value: One of UNKNOWN , INPUT , OUTPUT or INOUT Intended use: Describes the direction of the port description for the hierarchy viewer frontend Target: Ports de.thkoeln.fentwums.netlist.backend.hierarchy-ancestor-path \u00b6 Shortened option key: hierarchy-ancestor-path Type: String Intended use: Contains the path of the containing entity for a text-based hierarchy viewer Target: Nodes de.thkoeln.fentwums.netlist.backend.hierarchy-container-subnode-type \u00b6 Shortened option key: hierarchy-container-subnode-type Type: String Value: One of NAME , TYPE , PARAMETERS or PORTS Describes which section of the entities module representation is covered by this node Target: Nodes","title":"Extra layout options"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#extra-layout-options","text":"The following options have been added to the standard set of ELK options. They contain additional metadata about the netlist that helps frontends interact with the backend.#","title":"Extra layout options"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendsignalname","text":"Shortened option key: signalname Type: String Intended use: Contains the name of the signal this edge belongs to Target: Edges","title":"de.thkoeln.fentwums.netlist.backend.signalname"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendsignalindex","text":"Shortened option key: signalindex Type: Integer Intended use: Contains the bitindex of the signal this edge belongs to. It is globally unique within the netlist and is a positive integer greater than 1 Target: Edges","title":"de.thkoeln.fentwums.netlist.backend.signalindex"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendcellname","text":"Shortened option key: cellname Type: String Intended use: Contains the name of the cell described by this node Target: Nodes","title":"de.thkoeln.fentwums.netlist.backend.cellname"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendcelltype","text":"Shortened option key: celltype Type: String Intended use: Contains the type of the cell described by this node. Constant drivers are of type Constant driver . A list of the celltypes yosys is able to generate can be found here . Target: Nodes","title":"de.thkoeln.fentwums.netlist.backend.celltype"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendlocation-path","text":"Shortened option key: location-path Type: String Intended use: Contains the location of the cell or part of the signal described by this element inside the netlist hierarchy Targets: Nodes and Edges","title":"de.thkoeln.fentwums.netlist.backend.location-path"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendsrc-location","text":"Shortened option key: src-location Type: String Intended use: Contains the location of the HDL-Code that is represented (in part or completely) by this element. Contains the absolute file path as well as line and column numbers Targets: Nodes and Edges","title":"de.thkoeln.fentwums.netlist.backend.src-location"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendsignalvalue","text":"Shortened option key: signalvalue Type: String Intended use: Contains the current value of the signal represented by this edge. Each character is the value of one of the contained bitindices. Target: Edges","title":"de.thkoeln.fentwums.netlist.backend.signalvalue"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendindex-in-signal","text":"Shortened option key: index-in-signal Type: Integer Intended use: Contains the index of the signal described by this edge inside its containing signal (a vector). -1 if no containing signal exists Target: Edges","title":"de.thkoeln.fentwums.netlist.backend.index-in-signal"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendsignaltype","text":"Shortened option key: signaltype Type: String Value: One of CONSTANT , BUNDLED_CONSTANT , BUNDLED , SINGLE or UNDEFINED Intended use: Contains information about the type of signal represented by this edge Target: Edges","title":"de.thkoeln.fentwums.netlist.backend.signaltype"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendport-group-name","text":"Shortened option key: port-group-name Type: String Intended use: Contains the group a port belongs to, e.g. D , Q , S ... Target: Ports","title":"de.thkoeln.fentwums.netlist.backend.port-group-name"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendfont-size","text":"Shortened option key: font-size Type: double Intended use: The font size of the label this attribute is attached to Target: Labels","title":"de.thkoeln.fentwums.netlist.backend.font-size"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendnot-connected","text":"Shortened option key: not-connected Type: boolean Intended use: Any port where this option is set to true does not have outgoing or incoming connections. The viewer can therefore use the value of this option to add additional symbols showing the connectedness of ports Target: Ports","title":"de.thkoeln.fentwums.netlist.backend.not-connected"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendindex-in-port-group","text":"Shortened option key: index-in-port-group Type: Integer Intended use: Contains the index of the port inside the port group it belongs to Target: Edges","title":"de.thkoeln.fentwums.netlist.backend.index-in-port-group"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendcanonical-index-in-port-group","text":"Shortened option key: canonical-index-in-port-group Type: Integer Intended use: Contains the index of the port as described by the HDL sources. Can therefore be negative and may not start at index 0 Target: Ports","title":"de.thkoeln.fentwums.netlist.backend.canonical-index-in-port-group"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendcanonical-bundle-lower-index-in-port-group","text":"Shortened option key: canonical-bundle-lower-index-in-port-group Type: Integer Intended use: Contains the lowest contained canonical index of the bundle contained in this port. The range is continous between lower and upper limit Target: Ports","title":"de.thkoeln.fentwums.netlist.backend.canonical-bundle-lower-index-in-port-group"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendcanonical-bundle-upper-index-in-port-group","text":"Shortened option key: canonical-bundle-upper-index-in-port-group Type: Integer Intended use: Contains the highest contained canonical index of the bundle contained in this port Target: Ports","title":"de.thkoeln.fentwums.netlist.backend.canonical-bundle-upper-index-in-port-group"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendport-type","text":"Short option key: port-type Type: String Value: One of SIGNAL_SINGLE , SIGNAL_MULTIPLE , CONSTANT_SINGLE or CONSTANT_MULTIPLE Inteded use: Describes whether a port contains only one or multiple signals and whether they are constant or not Target: Ports","title":"de.thkoeln.fentwums.netlist.backend.port-type"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendport-direction","text":"Shortened option key: port-direction Type: String Value: One of UNKNOWN , INPUT , OUTPUT or INOUT Intended use: Describes the direction of the port description for the hierarchy viewer frontend Target: Ports","title":"de.thkoeln.fentwums.netlist.backend.port-direction"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendhierarchy-ancestor-path","text":"Shortened option key: hierarchy-ancestor-path Type: String Intended use: Contains the path of the containing entity for a text-based hierarchy viewer Target: Nodes","title":"de.thkoeln.fentwums.netlist.backend.hierarchy-ancestor-path"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendhierarchy-container-subnode-type","text":"Shortened option key: hierarchy-container-subnode-type Type: String Value: One of NAME , TYPE , PARAMETERS or PORTS Describes which section of the entities module representation is covered by this node Target: Nodes","title":"de.thkoeln.fentwums.netlist.backend.hierarchy-container-subnode-type"},{"location":"developer_guide/netlist_viewer/waveform_interactor/approach/","text":"Waveform Interactor \u00b6 To integrate the Netlist-Viewer seamless into the development workflow of OneWare, the functionality of its Waveform-Viewer has to be extended: Right-clicking on the signalname in OneWare's waveformviewer should offer context menus to: Navigate to the signal in the netlist-viewer. Jump to the HDLs source origin This component can be seen as an optional add-on to the Netlist-Viewer, it is useless without the Netlist-Viewer. It yet has to be merged into the production package. Steps to ensure navigation to netlist-viewer via waveform-viewer is possible \u00b6 The following section will describe the implementation approach of the Waveform-Interactor component. It utilizes several steps to ensure proper communication with the Netlist-Viewer plugin is possible: 1. Creating Verilog corresponding to Design (with Yosys) \u00b6 First a flattened verilog file has to be generated with yosys from the whole design (from the same yosys processing passes, which have been applied to the HDL to generate the netlist for the netlist-viewer). yosys -p \"read_verilog -nooverwrite <top_verilog.v> <other_verilog.v>; scratchpad -set flatten.separator \";\"; hierarchy -check -top <toplevel>; proc; memory -nomap; flatten -scopename; write_verilog <flattened_verilog.v>\" 2. Creating the simulation binary (with Verilator) \u00b6 This verilog file is verilated with Verilator to create compilable C++ sources. verilator --timescale-override 10ns/10ns -top-module <toplevel> -Wall --trace --exe --build -cc <testbench.cpp> <flattened_verilog.v> A simulation binary is compiled from a manual-written C++ Verilator testbench and the verilated files. More on Verilator and its simulation here . 3. Running the Simulation \u00b6 The simulation binary has to be executed, to run the simulation and dump simulation data in .vcd Waveform file. This has to be configured in the testbench. 4. Map yosys/netlist bit-indices to .vcd identifiers \u00b6 To ensure uniqueness, the Netlist-Viewer and Waveform Interactor identify signals via Bit-Index. This index is assigned by yosys during the processing passes. Each signal in the .vcd wavform file also has its own UID, consisting of 1 or 2 ASCII characters. To map Bit Indeces -> VCD Identifier, at first the signalname of the processed signal is used. After the yosys passes described in 2., these signalnames contain their scope, and are therefore unique. Bit Indices can be retrieved via the from the backend via its /get-net-information endpoint (see API information ). To make bitmapping-per-vcd persistent, this mapping is saved in a .json after successfully obtaining it via the backend. The mapping of each .vcd in a OneWare project is saved in <OneWare_project/build/simulation/bitmapping.json> Each .vcds body is hashed, as it uniquely represents the waveform, even when the scope hierarchy has been altered and recreated (See next chapter) . This vcdBodyHash holds the mapping of all VCD Identifier and their respective BitIndices of the .vcd. { \"<vcdBodyHash1>\":{ \"<vcdIdentifier>\":{ \"BitIndexId\": 2, \"BitIndices\": [ 2, 3, 4 ] }, ... }, \"<vcdBodyHash2>\":{ \"<vcdIdentifier>\":{ \"BitIndexId\": 1, \"BitIndices\": [ 1 ] }, ... } } Why not use the signalname as UID, if it is unique after the respective Yosys passes? \u00b6 The signalname will change after recreating the original scope hierarchy. This will lead to incorrect mapping of signalname -> vcdIdentifier. The mapping of the original .vcd can be reused, since the original and recreated vcd share the same body hash. 5. Recreate the original design hierarchy from the flattened netlist \u00b6 Since flattening the design is currently required, the signallist in the .vcd contains no scopes but the top scope. All signals lie in the same scope hierarchy. The idea is to recreate the VCD scope hierarchy from the net information contained in the netlist. This information is contained in the signalname generated by yosys after flattening. The backend also offers the /get-net-information endpoint to retrieve the scope information. To recreate this, the OneWare VCD datastructure has to be altered. This is currently not possible, since the corresponding signal and scope objects in the vcdView component, from which we can access OneWares parsed .vcd, is read-only. Parse the .vcd and write a new one with recreated hierarchy \u00b6 An alternative approach is to parse the .vcd definitions section into a dedicated data structure and reconstruct the original hierarchy based on the signal names. Each signal name encodes its parent scopes, with nested scopes separated by a specific character. Currently, this separator is ';', meaning a signal with two levels of hierarchy follows this format (for 2 scopes deep hierarchy): <scope_parent>;<scope>;<signal> From this simple structure the original hierarchy easily be recreated and written into the definitions section of the new .vcd. More on the .vcd format can be found here Since the signal values remain unchanged, the body of the original and the hierarchy-recreated .vcd stays identical. After writing the reconstructed hierarchy into the definitions section, the body is streamed directly to the new .vcd file. In OneWare right-clicking on the .vcd and selecting \"Recreate Hierarchy from Signal Names\" will generate the updated hierarchy. The new file will be saved as _recreated.vcd.","title":"Implementation Approach"},{"location":"developer_guide/netlist_viewer/waveform_interactor/approach/#waveform-interactor","text":"To integrate the Netlist-Viewer seamless into the development workflow of OneWare, the functionality of its Waveform-Viewer has to be extended: Right-clicking on the signalname in OneWare's waveformviewer should offer context menus to: Navigate to the signal in the netlist-viewer. Jump to the HDLs source origin This component can be seen as an optional add-on to the Netlist-Viewer, it is useless without the Netlist-Viewer. It yet has to be merged into the production package.","title":"Waveform Interactor"},{"location":"developer_guide/netlist_viewer/waveform_interactor/approach/#steps-to-ensure-navigation-to-netlist-viewer-via-waveform-viewer-is-possible","text":"The following section will describe the implementation approach of the Waveform-Interactor component. It utilizes several steps to ensure proper communication with the Netlist-Viewer plugin is possible:","title":"Steps to ensure navigation to netlist-viewer via waveform-viewer is possible"},{"location":"developer_guide/netlist_viewer/waveform_interactor/approach/#1-creating-verilog-corresponding-to-design-with-yosys","text":"First a flattened verilog file has to be generated with yosys from the whole design (from the same yosys processing passes, which have been applied to the HDL to generate the netlist for the netlist-viewer). yosys -p \"read_verilog -nooverwrite <top_verilog.v> <other_verilog.v>; scratchpad -set flatten.separator \";\"; hierarchy -check -top <toplevel>; proc; memory -nomap; flatten -scopename; write_verilog <flattened_verilog.v>\"","title":"1. Creating Verilog corresponding to Design (with Yosys)"},{"location":"developer_guide/netlist_viewer/waveform_interactor/approach/#2-creating-the-simulation-binary-with-verilator","text":"This verilog file is verilated with Verilator to create compilable C++ sources. verilator --timescale-override 10ns/10ns -top-module <toplevel> -Wall --trace --exe --build -cc <testbench.cpp> <flattened_verilog.v> A simulation binary is compiled from a manual-written C++ Verilator testbench and the verilated files. More on Verilator and its simulation here .","title":"2. Creating the simulation binary (with Verilator)"},{"location":"developer_guide/netlist_viewer/waveform_interactor/approach/#3-running-the-simulation","text":"The simulation binary has to be executed, to run the simulation and dump simulation data in .vcd Waveform file. This has to be configured in the testbench.","title":"3. Running the Simulation"},{"location":"developer_guide/netlist_viewer/waveform_interactor/approach/#4-map-yosysnetlist-bit-indices-to-vcd-identifiers","text":"To ensure uniqueness, the Netlist-Viewer and Waveform Interactor identify signals via Bit-Index. This index is assigned by yosys during the processing passes. Each signal in the .vcd wavform file also has its own UID, consisting of 1 or 2 ASCII characters. To map Bit Indeces -> VCD Identifier, at first the signalname of the processed signal is used. After the yosys passes described in 2., these signalnames contain their scope, and are therefore unique. Bit Indices can be retrieved via the from the backend via its /get-net-information endpoint (see API information ). To make bitmapping-per-vcd persistent, this mapping is saved in a .json after successfully obtaining it via the backend. The mapping of each .vcd in a OneWare project is saved in <OneWare_project/build/simulation/bitmapping.json> Each .vcds body is hashed, as it uniquely represents the waveform, even when the scope hierarchy has been altered and recreated (See next chapter) . This vcdBodyHash holds the mapping of all VCD Identifier and their respective BitIndices of the .vcd. { \"<vcdBodyHash1>\":{ \"<vcdIdentifier>\":{ \"BitIndexId\": 2, \"BitIndices\": [ 2, 3, 4 ] }, ... }, \"<vcdBodyHash2>\":{ \"<vcdIdentifier>\":{ \"BitIndexId\": 1, \"BitIndices\": [ 1 ] }, ... } }","title":"4. Map yosys/netlist bit-indices to .vcd identifiers"},{"location":"developer_guide/netlist_viewer/waveform_interactor/approach/#why-not-use-the-signalname-as-uid-if-it-is-unique-after-the-respective-yosys-passes","text":"The signalname will change after recreating the original scope hierarchy. This will lead to incorrect mapping of signalname -> vcdIdentifier. The mapping of the original .vcd can be reused, since the original and recreated vcd share the same body hash.","title":"Why not use the signalname as UID, if it is unique after the respective Yosys passes?"},{"location":"developer_guide/netlist_viewer/waveform_interactor/approach/#5-recreate-the-original-design-hierarchy-from-the-flattened-netlist","text":"Since flattening the design is currently required, the signallist in the .vcd contains no scopes but the top scope. All signals lie in the same scope hierarchy. The idea is to recreate the VCD scope hierarchy from the net information contained in the netlist. This information is contained in the signalname generated by yosys after flattening. The backend also offers the /get-net-information endpoint to retrieve the scope information. To recreate this, the OneWare VCD datastructure has to be altered. This is currently not possible, since the corresponding signal and scope objects in the vcdView component, from which we can access OneWares parsed .vcd, is read-only.","title":"5. Recreate the original design hierarchy from the flattened netlist"},{"location":"developer_guide/netlist_viewer/waveform_interactor/approach/#parse-the-vcd-and-write-a-new-one-with-recreated-hierarchy","text":"An alternative approach is to parse the .vcd definitions section into a dedicated data structure and reconstruct the original hierarchy based on the signal names. Each signal name encodes its parent scopes, with nested scopes separated by a specific character. Currently, this separator is ';', meaning a signal with two levels of hierarchy follows this format (for 2 scopes deep hierarchy): <scope_parent>;<scope>;<signal> From this simple structure the original hierarchy easily be recreated and written into the definitions section of the new .vcd. More on the .vcd format can be found here Since the signal values remain unchanged, the body of the original and the hierarchy-recreated .vcd stays identical. After writing the reconstructed hierarchy into the definitions section, the body is streamed directly to the new .vcd file. In OneWare right-clicking on the .vcd and selecting \"Recreate Hierarchy from Signal Names\" will generate the updated hierarchy. The new file will be saved as _recreated.vcd.","title":"Parse the .vcd and write a new one with recreated hierarchy"},{"location":"user_guide/design_tools/","text":"Design Tools \u00b6 The design tools offer an easy-to-use design flow to implement and debug digital circuits in OneWare. NetlistViewer \u00b6 The main feature is the NetlistViewer . It is built on top of the open-source tool yosys . Yosys parses the HDL design and outputs the netlist, which is then converted by the FEntwumS Backend into a layout. This layout is used by the Frontend to render a graph view. To make development with OneWare seamless, the FEntwumS Plugins add interactions to OneWare's Waveform Viewer. This way, the Waveform Viewer, Netlist Viewer, and Source Code are connected via mouse clicks, making it easy to jump from one view to another while debugging.","title":"Design Tools"},{"location":"user_guide/design_tools/#design-tools","text":"The design tools offer an easy-to-use design flow to implement and debug digital circuits in OneWare.","title":"Design Tools"},{"location":"user_guide/design_tools/#netlistviewer","text":"The main feature is the NetlistViewer . It is built on top of the open-source tool yosys . Yosys parses the HDL design and outputs the netlist, which is then converted by the FEntwumS Backend into a layout. This layout is used by the Frontend to render a graph view. To make development with OneWare seamless, the FEntwumS Plugins add interactions to OneWare's Waveform Viewer. This way, the Waveform Viewer, Netlist Viewer, and Source Code are connected via mouse clicks, making it easy to jump from one view to another while debugging.","title":"NetlistViewer"},{"location":"user_guide/oneware/","text":"A brief introduction to OneWare Studio and its plugins \u00b6 OneWare is built on the .NET SDK 9.0 . It uses the Avalonia frontend framework. To start developing a plugin for OneWare, use the template, OneWare provides and follow the steps here: https://one-ware.com/docs/studio/plugins/write-plugin/. It is advised to use Intellij Rider to develop the .NET OneWare Plugins. It packs a comprehensive building/running and debugging workflow for .NETs module management. Plugin Development with multiple projects/plugins \u00b6 To load multiple plugins/DLLs simultaneously during development in OneWare: Compile each project into a common build folder. This folder holds the DLLs from all your compiled projects. In the above example project structure is: project-root/ \u251c\u2500\u2500 bin/Debug/net9.0/ # Common build folder for compiled plugins/DLLs \u251c\u2500\u2500 FEntwums.NetlistViewer.dll \u251c\u2500\u2500 WaveformInteractor.dll \u2514\u2500\u2500 ... \u251c\u2500\u2500 src/ # Source code for individual plugins \u2502 \u251c\u2500\u2500 FEntwums.NetlistViewer/ \u2502 \u2502 \u251c\u2500\u2500 src/ \u2502 \u2502 \u251c\u2500\u2500 FEntwumS.NetlistViewer.csproj \u2502 \u2502 \u251c\u2500\u2500 FEntwumSNetlistReaderFrontendModule.cs \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u251c\u2500\u2500 FEntwums.WaveformInteractor/ \u2502 \u2502 \u251c\u2500\u2500 src/ \u2502 \u2502 \u251c\u2500\u2500 FEntwumS.WaveformInteractor.csproj \u2502 \u2502 \u251c\u2500\u2500 FEntwumSWaveformInteractorModule.cs \u2502 \u2502 \u2514\u2500\u2500 ... Pass the ./bin/Debug/net9.0 folder as a parameter to the OneWare executable in your IDE's launch configuration: Prism \u00b6 OneWare currently uses Prism to enable loosely coupled development. This also enables plugin development for OneWare. The plugin registers itself in the container registry, when being loaded in OneWare. NuGet \u00b6 NuGet is a package manager for the Microsoft development platform, primarily used for managing .NET libraries and dependencies. It the process of incorporating third-party libraries into .NET projects by providing a central repository of reusable code packages. OneWare uses NuGet to provide its API via shared packages. This way your OneWare plugin development can always use the newest API OneWare provides for the interaction with your plugin. NuGet package management can also be done from Rider. If your plugin is dependend on another plugins NuGet packages, a local NuGet repositories often make sense. Since publishing NuGet repositories in the development of your plugin is often not desired. A local NuGet Feed can be created,then fetched from your .NET project. Look into it here .","title":"OneWare"},{"location":"user_guide/oneware/#a-brief-introduction-to-oneware-studio-and-its-plugins","text":"OneWare is built on the .NET SDK 9.0 . It uses the Avalonia frontend framework. To start developing a plugin for OneWare, use the template, OneWare provides and follow the steps here: https://one-ware.com/docs/studio/plugins/write-plugin/. It is advised to use Intellij Rider to develop the .NET OneWare Plugins. It packs a comprehensive building/running and debugging workflow for .NETs module management.","title":"A brief introduction to OneWare Studio and its plugins"},{"location":"user_guide/oneware/#plugin-development-with-multiple-projectsplugins","text":"To load multiple plugins/DLLs simultaneously during development in OneWare: Compile each project into a common build folder. This folder holds the DLLs from all your compiled projects. In the above example project structure is: project-root/ \u251c\u2500\u2500 bin/Debug/net9.0/ # Common build folder for compiled plugins/DLLs \u251c\u2500\u2500 FEntwums.NetlistViewer.dll \u251c\u2500\u2500 WaveformInteractor.dll \u2514\u2500\u2500 ... \u251c\u2500\u2500 src/ # Source code for individual plugins \u2502 \u251c\u2500\u2500 FEntwums.NetlistViewer/ \u2502 \u2502 \u251c\u2500\u2500 src/ \u2502 \u2502 \u251c\u2500\u2500 FEntwumS.NetlistViewer.csproj \u2502 \u2502 \u251c\u2500\u2500 FEntwumSNetlistReaderFrontendModule.cs \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u251c\u2500\u2500 FEntwums.WaveformInteractor/ \u2502 \u2502 \u251c\u2500\u2500 src/ \u2502 \u2502 \u251c\u2500\u2500 FEntwumS.WaveformInteractor.csproj \u2502 \u2502 \u251c\u2500\u2500 FEntwumSWaveformInteractorModule.cs \u2502 \u2502 \u2514\u2500\u2500 ... Pass the ./bin/Debug/net9.0 folder as a parameter to the OneWare executable in your IDE's launch configuration:","title":"Plugin Development with multiple projects/plugins"},{"location":"user_guide/oneware/#prism","text":"OneWare currently uses Prism to enable loosely coupled development. This also enables plugin development for OneWare. The plugin registers itself in the container registry, when being loaded in OneWare.","title":"Prism"},{"location":"user_guide/oneware/#nuget","text":"NuGet is a package manager for the Microsoft development platform, primarily used for managing .NET libraries and dependencies. It the process of incorporating third-party libraries into .NET projects by providing a central repository of reusable code packages. OneWare uses NuGet to provide its API via shared packages. This way your OneWare plugin development can always use the newest API OneWare provides for the interaction with your plugin. NuGet package management can also be done from Rider. If your plugin is dependend on another plugins NuGet packages, a local NuGet repositories often make sense. Since publishing NuGet repositories in the development of your plugin is often not desired. A local NuGet Feed can be created,then fetched from your .NET project. Look into it here .","title":"NuGet"}]}