{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FEntwumS Project Documenation - An Open-Source FPGA Development Environment \u00b6 This project focuses on the development of an intuitive, open-source development environment for FPGAs. The goal is to create comprehensive design tools with simulation and visualization capabilities for implementing digital circuits. These docs should help you get started and contribute to this project. Project Structure \u00b6 FEntwumS can be divided into three subprojects: FPGA Design Tools : Visualization and simulation features for digital circuit development. Graphical System Builder and Circuit Design Tool : A graphical design tool for creating custom SoC configurations. AI Accelerator : Development of tools and accelerators designed for efficient processing of AI algorithms. This GitHub organization focuses on the first two subprojects. They are implemented as multiple plugins for OneWare Studio , an open-source IDE for FPGA design. Read more about general OneWare (plugin) development in A Brief Introduction to OneWare Studio and its Plugins .","title":"Home"},{"location":"#fentwums-project-documenation-an-open-source-fpga-development-environment","text":"This project focuses on the development of an intuitive, open-source development environment for FPGAs. The goal is to create comprehensive design tools with simulation and visualization capabilities for implementing digital circuits. These docs should help you get started and contribute to this project.","title":"FEntwumS Project Documenation - An Open-Source FPGA Development Environment"},{"location":"#project-structure","text":"FEntwumS can be divided into three subprojects: FPGA Design Tools : Visualization and simulation features for digital circuit development. Graphical System Builder and Circuit Design Tool : A graphical design tool for creating custom SoC configurations. AI Accelerator : Development of tools and accelerators designed for efficient processing of AI algorithms. This GitHub organization focuses on the first two subprojects. They are implemented as multiple plugins for OneWare Studio , an open-source IDE for FPGA design. Read more about general OneWare (plugin) development in A Brief Introduction to OneWare Studio and its Plugins .","title":"Project Structure"},{"location":"about/","text":"About \u00b6 This documentation is written in .md and generated via mkdocs .","title":"About"},{"location":"about/#about","text":"This documentation is written in .md and generated via mkdocs .","title":"About"},{"location":"design_tools/","text":"Design Tools \u00b6 The design tools offer an easy-to-use design flow to implement and debug digital circuits in OneWare. NetlistViewer \u00b6 The main feature is the NetlistViewer . It is built on top of the open-source tool yosys . Yosys parses the HDL design and outputs the netlist, which is then converted by the FEntwumS Backend into a layout. This layout is used by the Frontend to render a graph view. To make development with OneWare seamless, the FEntwumS Plugins add interactions to OneWare's Waveform Viewer. This way, the Waveform Viewer, Netlist Viewer, and Source Code are connected via mouse clicks, making it easy to jump from one view to another while debugging.","title":"Design Tools"},{"location":"design_tools/#design-tools","text":"The design tools offer an easy-to-use design flow to implement and debug digital circuits in OneWare.","title":"Design Tools"},{"location":"design_tools/#netlistviewer","text":"The main feature is the NetlistViewer . It is built on top of the open-source tool yosys . Yosys parses the HDL design and outputs the netlist, which is then converted by the FEntwumS Backend into a layout. This layout is used by the Frontend to render a graph view. To make development with OneWare seamless, the FEntwumS Plugins add interactions to OneWare's Waveform Viewer. This way, the Waveform Viewer, Netlist Viewer, and Source Code are connected via mouse clicks, making it easy to jump from one view to another while debugging.","title":"NetlistViewer"},{"location":"oneware/","text":"A brief introduction to OneWare Studio and its plugins \u00b6 OneWare is built on the .NET SDK 9.0 . It uses the Avalonia frontend framework. To start developing a plugin for OneWare, use the template, OneWare provides and follow the steps here: https://one-ware.com/docs/studio/plugins/write-plugin/. It is advised to use Intellij Rider to develop the .NET OneWare Plugins. It packs a comprehensive building/running and debugging workflow for .NETs module management. Prism \u00b6 OneWare currently uses Prism to enable loosely coupled development. This also enables plugin development for OneWare. The plugin registers itself in the container registry, when being loaded in OneWare. NuGet \u00b6 NuGet is a package manager for the Microsoft development platform, primarily used for managing .NET libraries and dependencies. It the process of incorporating third-party libraries into .NET projects by providing a central repository of reusable code packages. OneWare uses NuGet to provide its API via shared packages. This way your OneWare plugin development can always use the newest API OneWare provides for the interaction with your plugin. NuGet package management can also be done from Rider. If your plugin is dependend on another plugins NuGet packages, a local NuGet repositories often make sense. Since publishing NuGet repositories in the development of your plugin is often not desired. A local NuGet Feed can be created,then fetched from your .NET project. Look into it here .","title":"OneWare"},{"location":"oneware/#a-brief-introduction-to-oneware-studio-and-its-plugins","text":"OneWare is built on the .NET SDK 9.0 . It uses the Avalonia frontend framework. To start developing a plugin for OneWare, use the template, OneWare provides and follow the steps here: https://one-ware.com/docs/studio/plugins/write-plugin/. It is advised to use Intellij Rider to develop the .NET OneWare Plugins. It packs a comprehensive building/running and debugging workflow for .NETs module management.","title":"A brief introduction to OneWare Studio and its plugins"},{"location":"oneware/#prism","text":"OneWare currently uses Prism to enable loosely coupled development. This also enables plugin development for OneWare. The plugin registers itself in the container registry, when being loaded in OneWare.","title":"Prism"},{"location":"oneware/#nuget","text":"NuGet is a package manager for the Microsoft development platform, primarily used for managing .NET libraries and dependencies. It the process of incorporating third-party libraries into .NET projects by providing a central repository of reusable code packages. OneWare uses NuGet to provide its API via shared packages. This way your OneWare plugin development can always use the newest API OneWare provides for the interaction with your plugin. NuGet package management can also be done from Rider. If your plugin is dependend on another plugins NuGet packages, a local NuGet repositories often make sense. Since publishing NuGet repositories in the development of your plugin is often not desired. A local NuGet Feed can be created,then fetched from your .NET project. Look into it here .","title":"NuGet"},{"location":"developer_guide/netlist_viewer/api_information/","text":"Backend API information for frontend developers \u00b6 Format of the layouted netlist \u00b6 The returned JSON document is formatted as ELK-JSON. The exact specification may be found in the ELK documentation . The following options are used in the generation of the document: omitZeroDimension \u2192 Whenever no dimension is specified for a given element, the receiving program should assume that it is 0 instead omitZeroPosition \u2192 Whenever no position is specified for a given element, the receiving program should assume that it is 0 instead shortLayoutOptionKeys \u2192 All layout options are shortened to reduce file size The document contains some, if not all the options described here in addition to the layout options included in ELK. Hash generation \u00b6 To uniquely identify the netlists on the backend server, the client must send an identifying hash alongside them. This hash is generated using the one_at_a_time hash function by Bob Jenkins. The hash is a 64 bit unsigned integer, where the upper 32 bits are the hashed absolute path of the netlist file, while the lower 32 bits are the hashed contents of the netlist file. Creating a graph representation of a given netlist \u00b6 /graphLocalFile \u00b6 Parameters: filename : The absolute path pointing to the netlist file hash : The hash that is to be usd for this file. This hash is generated as described here Notes: - This call only works when the file is located on the same system as the running backend executable. /graphRemoteFile \u00b6 Parameters: file : A multipart file, containing the netlist files' contents hash : The hash that is to be usd for this file. This hash is generated as described here Modifying or retreiving an existing graph \u00b6 The following calls only return results if the referenced netlist already exists on the backend server. /expandNode \u00b6 This call collapses the given cell, if it is expanded (its' children are visible) or vice-versa. Parameters: hash : The hash that is to be usd for this file. This hash is generated as described here nodepath : The path of the node that is to be collapsed or expanded. Can be found in the location-path option Notes: While cells have their location-path set, they can neither be expanded or collapsed, as they have no children This call forces a partial re-layout of the graph. Depending on the number of visible entities and cells, this may take a while. /get-current-graph \u00b6 Parameters: hash : The hash that is to be usd for this file. This hash is generated as described here Mapping signal names to yosys bitindices \u00b6 /get-net-information \u00b6 Parameters: hash : The hash that is to be usd for this file. This hash is generated as described here Notes: The JSON document is formatted as follows: { \"signals\": { \"<signalname>\": { \"scope\": \"<hdlname|scopename>\", \"bits\": [ <bitindex>, ... ] }, ... } }","title":"Backend API information"},{"location":"developer_guide/netlist_viewer/api_information/#backend-api-information-for-frontend-developers","text":"","title":"Backend API information for frontend developers"},{"location":"developer_guide/netlist_viewer/api_information/#format-of-the-layouted-netlist","text":"The returned JSON document is formatted as ELK-JSON. The exact specification may be found in the ELK documentation . The following options are used in the generation of the document: omitZeroDimension \u2192 Whenever no dimension is specified for a given element, the receiving program should assume that it is 0 instead omitZeroPosition \u2192 Whenever no position is specified for a given element, the receiving program should assume that it is 0 instead shortLayoutOptionKeys \u2192 All layout options are shortened to reduce file size The document contains some, if not all the options described here in addition to the layout options included in ELK.","title":"Format of the layouted netlist"},{"location":"developer_guide/netlist_viewer/api_information/#hash-generation","text":"To uniquely identify the netlists on the backend server, the client must send an identifying hash alongside them. This hash is generated using the one_at_a_time hash function by Bob Jenkins. The hash is a 64 bit unsigned integer, where the upper 32 bits are the hashed absolute path of the netlist file, while the lower 32 bits are the hashed contents of the netlist file.","title":"Hash generation"},{"location":"developer_guide/netlist_viewer/api_information/#creating-a-graph-representation-of-a-given-netlist","text":"","title":"Creating a graph representation of a given netlist"},{"location":"developer_guide/netlist_viewer/api_information/#graphlocalfile","text":"Parameters: filename : The absolute path pointing to the netlist file hash : The hash that is to be usd for this file. This hash is generated as described here Notes: - This call only works when the file is located on the same system as the running backend executable.","title":"/graphLocalFile"},{"location":"developer_guide/netlist_viewer/api_information/#graphremotefile","text":"Parameters: file : A multipart file, containing the netlist files' contents hash : The hash that is to be usd for this file. This hash is generated as described here","title":"/graphRemoteFile"},{"location":"developer_guide/netlist_viewer/api_information/#modifying-or-retreiving-an-existing-graph","text":"The following calls only return results if the referenced netlist already exists on the backend server.","title":"Modifying or retreiving an existing graph"},{"location":"developer_guide/netlist_viewer/api_information/#expandnode","text":"This call collapses the given cell, if it is expanded (its' children are visible) or vice-versa. Parameters: hash : The hash that is to be usd for this file. This hash is generated as described here nodepath : The path of the node that is to be collapsed or expanded. Can be found in the location-path option Notes: While cells have their location-path set, they can neither be expanded or collapsed, as they have no children This call forces a partial re-layout of the graph. Depending on the number of visible entities and cells, this may take a while.","title":"/expandNode"},{"location":"developer_guide/netlist_viewer/api_information/#get-current-graph","text":"Parameters: hash : The hash that is to be usd for this file. This hash is generated as described here","title":"/get-current-graph"},{"location":"developer_guide/netlist_viewer/api_information/#mapping-signal-names-to-yosys-bitindices","text":"","title":"Mapping signal names to yosys bitindices"},{"location":"developer_guide/netlist_viewer/api_information/#get-net-information","text":"Parameters: hash : The hash that is to be usd for this file. This hash is generated as described here Notes: The JSON document is formatted as follows: { \"signals\": { \"<signalname>\": { \"scope\": \"<hdlname|scopename>\", \"bits\": [ <bitindex>, ... ] }, ... } }","title":"/get-net-information"},{"location":"developer_guide/netlist_viewer/development_setup/","text":"Prerequisites \u00b6 To work on developing the netlist viewer, you need to have the following tools installed: JDK 21 or higher .net 9.0 maven 3.9 or higher (recommended) a Java IDE such as IntelliJ Idea (recommended) a C# IDE such as Jetbrains Rider Compiling OneWare Studio \u00b6 The official developer documentation for plugin development with for OneWare Studio can be found here . It is recommended to compile your own version of OneWare Studio for plugin development. Just clone the OneWare Studio source code from here . It may be necessary to check out a ceratin commit before you can start building OneWare Studio. Please check the readme for any such notices. Once you have completed the previous steps, you can start the compilation. Please first select the correct project to build (namely OneWare.Studio.Desktop ), then compile the project. From the base directory of your local git repo, you should now be able to find the OneWare Studio executable (eg OneWareStudio.exe ) under studio/OneWare.Studio.Desktop/bin/Debug/net9.0/[your target platform, eg win-x64]/ . Compiling the plugin \u00b6 In another directory, clone the plugin repository . To be able to directly run the plugin from Rider, add a new run configuration. For the Exe path , enter the directory of the OneWare Studio executable you previously compiled. For Program arguments , enter --modules ./ . And for the Working directory , enter [plugin git repo]/src/FEntwumS.NetlistViewer/bin/debug/net9.0 . If you followed all the instructions, running the configuration should open OneWare Studio with the FEntwumS netlist viewer plugin loaded. Compiling the backend \u00b6 If you want to work on the backend, please follow the instructions here to compile your own version. If you want to test any changes you made, start the backend manually using java -jar fentwums-netlist-reader-server-[version number]-exec.jar in the fentwums-netlist-reader-server/target directory. The frontend plugin will automatically use the already running backend.","title":"Development setup"},{"location":"developer_guide/netlist_viewer/development_setup/#prerequisites","text":"To work on developing the netlist viewer, you need to have the following tools installed: JDK 21 or higher .net 9.0 maven 3.9 or higher (recommended) a Java IDE such as IntelliJ Idea (recommended) a C# IDE such as Jetbrains Rider","title":"Prerequisites"},{"location":"developer_guide/netlist_viewer/development_setup/#compiling-oneware-studio","text":"The official developer documentation for plugin development with for OneWare Studio can be found here . It is recommended to compile your own version of OneWare Studio for plugin development. Just clone the OneWare Studio source code from here . It may be necessary to check out a ceratin commit before you can start building OneWare Studio. Please check the readme for any such notices. Once you have completed the previous steps, you can start the compilation. Please first select the correct project to build (namely OneWare.Studio.Desktop ), then compile the project. From the base directory of your local git repo, you should now be able to find the OneWare Studio executable (eg OneWareStudio.exe ) under studio/OneWare.Studio.Desktop/bin/Debug/net9.0/[your target platform, eg win-x64]/ .","title":"Compiling OneWare Studio"},{"location":"developer_guide/netlist_viewer/development_setup/#compiling-the-plugin","text":"In another directory, clone the plugin repository . To be able to directly run the plugin from Rider, add a new run configuration. For the Exe path , enter the directory of the OneWare Studio executable you previously compiled. For Program arguments , enter --modules ./ . And for the Working directory , enter [plugin git repo]/src/FEntwumS.NetlistViewer/bin/debug/net9.0 . If you followed all the instructions, running the configuration should open OneWare Studio with the FEntwumS netlist viewer plugin loaded.","title":"Compiling the plugin"},{"location":"developer_guide/netlist_viewer/development_setup/#compiling-the-backend","text":"If you want to work on the backend, please follow the instructions here to compile your own version. If you want to test any changes you made, start the backend manually using java -jar fentwums-netlist-reader-server-[version number]-exec.jar in the fentwums-netlist-reader-server/target directory. The frontend plugin will automatically use the already running backend.","title":"Compiling the backend"},{"location":"developer_guide/netlist_viewer/extra_layout_options/","text":"Extra layout options \u00b6 The following options have been added to the standard set of ELK options. They contain additional metadata about the netlist that helps frontends interact with the backend.# de.thkoeln.fentwums.netlist.backend.signalname \u00b6 Shortened option key: signalname Type: String Intended use: Contains the name of the signal this edge belongs to Target: Edges de.thkoeln.fentwums.netlist.backend.signalindex \u00b6 Shortened option key: signalindex Type: Integer Intended use: Contains the bitindex of the signal this edge belongs to. It is globally unique within the netlist and is a positive integer greater than 1 Target: Edges de.thkoeln.fentwums.netlist.backend.cellname \u00b6 Shortened option key: cellname Type: String Intended use: Contains the name of the cell described by this node Target: Nodes de.thkoeln.fentwums.netlist.backend.celltype \u00b6 Shortened option key: celltype Type: String Intended use: Contains the type of the cell described by this node. Constant drivers are of type Constant driver . A list of the celltypes yosys is able to generate can be found here . Target: Nodes de.thkoeln.fentwums.netlist.backend.location-path \u00b6 Shortened option key: location-path Type: String Intended use: Contains the location of the cell or part of the signal described by this element inside the netlist hierarchy Targets: Nodes and Edges de.thkoeln.fentwums.netlist.backend.src-location \u00b6 Shortened option key: src-location Type: String Intended use: Contains the location of the HDL-Code that is represented (in part or completely) by this element. Contains the absolute file path as well as line and column numbers Targets: Nodes and Edges de.thkoeln.fentwums.netlist.backend.signalvalue \u00b6 Shortened option key: signalvalue Type: String Intended use: Contains the current value of the signal represented by this edge. Each character is the value of one of the contained bitindices. Target: Edges de.thkoeln.fentwums.netlist.backend.index-in-signal \u00b6 Shortened option key: index-in-signal Type: Integer Intended use: Contains the index of the signal described by this edge inside its containing signal (a vector). -1 if no containing signal exists Target: Edges de.thkoeln.fentwums.netlist.backend.signaltype \u00b6 Shortened option key: signaltype Type: String Value: One of CONSTANT , BUNDLED_CONSTANT , BUNDLED , SINGLE or UNDEFINED Intended use: Contains information about the type of signal represented by this edge Target: Edges de.thkoeln.fentwums.netlist.backend.port-group-name \u00b6 Shortened option key: port-group-name Type: String Intended use: Contains the group a port belongs to, e.g. D , Q , S ... Target: Ports de.thkoeln.fentwums.netlist.backend.font-size \u00b6 Shortened option key: font-size Type: double Intended use: The font size of the label this attribute is attached to Target: Labels","title":"Extra layout options"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#extra-layout-options","text":"The following options have been added to the standard set of ELK options. They contain additional metadata about the netlist that helps frontends interact with the backend.#","title":"Extra layout options"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendsignalname","text":"Shortened option key: signalname Type: String Intended use: Contains the name of the signal this edge belongs to Target: Edges","title":"de.thkoeln.fentwums.netlist.backend.signalname"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendsignalindex","text":"Shortened option key: signalindex Type: Integer Intended use: Contains the bitindex of the signal this edge belongs to. It is globally unique within the netlist and is a positive integer greater than 1 Target: Edges","title":"de.thkoeln.fentwums.netlist.backend.signalindex"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendcellname","text":"Shortened option key: cellname Type: String Intended use: Contains the name of the cell described by this node Target: Nodes","title":"de.thkoeln.fentwums.netlist.backend.cellname"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendcelltype","text":"Shortened option key: celltype Type: String Intended use: Contains the type of the cell described by this node. Constant drivers are of type Constant driver . A list of the celltypes yosys is able to generate can be found here . Target: Nodes","title":"de.thkoeln.fentwums.netlist.backend.celltype"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendlocation-path","text":"Shortened option key: location-path Type: String Intended use: Contains the location of the cell or part of the signal described by this element inside the netlist hierarchy Targets: Nodes and Edges","title":"de.thkoeln.fentwums.netlist.backend.location-path"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendsrc-location","text":"Shortened option key: src-location Type: String Intended use: Contains the location of the HDL-Code that is represented (in part or completely) by this element. Contains the absolute file path as well as line and column numbers Targets: Nodes and Edges","title":"de.thkoeln.fentwums.netlist.backend.src-location"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendsignalvalue","text":"Shortened option key: signalvalue Type: String Intended use: Contains the current value of the signal represented by this edge. Each character is the value of one of the contained bitindices. Target: Edges","title":"de.thkoeln.fentwums.netlist.backend.signalvalue"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendindex-in-signal","text":"Shortened option key: index-in-signal Type: Integer Intended use: Contains the index of the signal described by this edge inside its containing signal (a vector). -1 if no containing signal exists Target: Edges","title":"de.thkoeln.fentwums.netlist.backend.index-in-signal"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendsignaltype","text":"Shortened option key: signaltype Type: String Value: One of CONSTANT , BUNDLED_CONSTANT , BUNDLED , SINGLE or UNDEFINED Intended use: Contains information about the type of signal represented by this edge Target: Edges","title":"de.thkoeln.fentwums.netlist.backend.signaltype"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendport-group-name","text":"Shortened option key: port-group-name Type: String Intended use: Contains the group a port belongs to, e.g. D , Q , S ... Target: Ports","title":"de.thkoeln.fentwums.netlist.backend.port-group-name"},{"location":"developer_guide/netlist_viewer/extra_layout_options/#dethkoelnfentwumsnetlistbackendfont-size","text":"Shortened option key: font-size Type: double Intended use: The font size of the label this attribute is attached to Target: Labels","title":"de.thkoeln.fentwums.netlist.backend.font-size"},{"location":"developer_guide/waveform_interactor/approach/","text":"Waveform Interactor \u00b6 To integrate the Netlist-Viewer seamless into the development workflow of OneWare, the functionality of its Waveform-Viewer has to be extended: Right-clicking on the signalname in OneWare's waveformviewer should offer context menus to: Navigate to the signal in the netlist-viewer. Jump to the HDLs source origin Steps to ensure navigation to netlist-viewer via waveform-viewer is possible \u00b6 1. Creating Verilog corresponding to Design (with Yosys) \u00b6 First a flattened verilog file has to be generated with yosys from the whole design (from the same yosys processing passes, which have been applied to the HDL to generate the netlist for the netlist-viewer). yosys -p \"read_verilog -nooverwrite <top_verilog.v> <other_verilog.v>; scratchpad -set flatten.separator \";\"; hierarchy -check -top <toplevel>; proc; memory -nomap; flatten -scopename; write_verilog <flattened_verilog.v>\" 2. Creating the simulation binary (with Verilator) \u00b6 This verilog file is verilated with Verilator to create compilable C++ sources. verilator --timescale-override 10ns/10ns -top-module <toplevel> -Wall --trace --exe --build -cc <testbench.cpp> <flattened_verilog.v> A simulation binary is compiled from a manual-written C++ Verilator testbench and the verilated files. More on Verilator and its simulation here . 3. Running the Simulation \u00b6 The simulation binary has to be executed, to run the simulation and dump simulation data in .vcd Waveform file. This has to be configured in the testbench. 4. Map yosys/netlist bit-indices to .vcd identifiers \u00b6 To ensure uniqueness, the Netlist-Viewer and Waveform Interactor identify signals via Bit-Index. This index is assigned by yosys during the processing passes. Each signal in the .vcd wavform file also has its own UID, consisting of 1 or 2 ASCII characters. To map Bit Indeces -> VCD UID, at first the signalname of the processed signal is used. After the yosys passes described in 2., these signalnames contain their scope, and are therefore unique. Bit Indices can be retrieved via the from the backend via its /get-net-information endpoint (see API information ). Why not use the signalname as UID, if it is unique after the respective Yosys passes? \u00b6 5. Recreate the original design hierarchy from the flattened netlist \u00b6 Since flattening the design is currently required, the signallist in the .vcd contains no scopes at all. All signals lie in the same scope hierarchy. The idea is to recreate the .vcd scope hierarchy from the net information contained in the netlist. This information is also contained in the .json returned by the backends /get-net-information endpoint. To recreate this, the OneWare VCD datastructure has to be altered. This is currently not possible, since the corresponding attributes in the vcdView component, from which we can access OneWares parsed .vcd, is read-only. Another way would be to read the .vcd, alter it before it is parsed by OneWare. Maybe this is all not necessary, since Flojo is working on a pass without flattening.","title":"Implementation Approach"},{"location":"developer_guide/waveform_interactor/approach/#waveform-interactor","text":"To integrate the Netlist-Viewer seamless into the development workflow of OneWare, the functionality of its Waveform-Viewer has to be extended: Right-clicking on the signalname in OneWare's waveformviewer should offer context menus to: Navigate to the signal in the netlist-viewer. Jump to the HDLs source origin","title":"Waveform Interactor"},{"location":"developer_guide/waveform_interactor/approach/#steps-to-ensure-navigation-to-netlist-viewer-via-waveform-viewer-is-possible","text":"","title":"Steps to ensure navigation to netlist-viewer via waveform-viewer is possible"},{"location":"developer_guide/waveform_interactor/approach/#1-creating-verilog-corresponding-to-design-with-yosys","text":"First a flattened verilog file has to be generated with yosys from the whole design (from the same yosys processing passes, which have been applied to the HDL to generate the netlist for the netlist-viewer). yosys -p \"read_verilog -nooverwrite <top_verilog.v> <other_verilog.v>; scratchpad -set flatten.separator \";\"; hierarchy -check -top <toplevel>; proc; memory -nomap; flatten -scopename; write_verilog <flattened_verilog.v>\"","title":"1. Creating Verilog corresponding to Design (with Yosys)"},{"location":"developer_guide/waveform_interactor/approach/#2-creating-the-simulation-binary-with-verilator","text":"This verilog file is verilated with Verilator to create compilable C++ sources. verilator --timescale-override 10ns/10ns -top-module <toplevel> -Wall --trace --exe --build -cc <testbench.cpp> <flattened_verilog.v> A simulation binary is compiled from a manual-written C++ Verilator testbench and the verilated files. More on Verilator and its simulation here .","title":"2. Creating the simulation binary (with Verilator)"},{"location":"developer_guide/waveform_interactor/approach/#3-running-the-simulation","text":"The simulation binary has to be executed, to run the simulation and dump simulation data in .vcd Waveform file. This has to be configured in the testbench.","title":"3. Running the Simulation"},{"location":"developer_guide/waveform_interactor/approach/#4-map-yosysnetlist-bit-indices-to-vcd-identifiers","text":"To ensure uniqueness, the Netlist-Viewer and Waveform Interactor identify signals via Bit-Index. This index is assigned by yosys during the processing passes. Each signal in the .vcd wavform file also has its own UID, consisting of 1 or 2 ASCII characters. To map Bit Indeces -> VCD UID, at first the signalname of the processed signal is used. After the yosys passes described in 2., these signalnames contain their scope, and are therefore unique. Bit Indices can be retrieved via the from the backend via its /get-net-information endpoint (see API information ).","title":"4. Map yosys/netlist bit-indices to .vcd identifiers"},{"location":"developer_guide/waveform_interactor/approach/#why-not-use-the-signalname-as-uid-if-it-is-unique-after-the-respective-yosys-passes","text":"","title":"Why not use the signalname as UID, if it is unique after the respective Yosys passes?"},{"location":"developer_guide/waveform_interactor/approach/#5-recreate-the-original-design-hierarchy-from-the-flattened-netlist","text":"Since flattening the design is currently required, the signallist in the .vcd contains no scopes at all. All signals lie in the same scope hierarchy. The idea is to recreate the .vcd scope hierarchy from the net information contained in the netlist. This information is also contained in the .json returned by the backends /get-net-information endpoint. To recreate this, the OneWare VCD datastructure has to be altered. This is currently not possible, since the corresponding attributes in the vcdView component, from which we can access OneWares parsed .vcd, is read-only. Another way would be to read the .vcd, alter it before it is parsed by OneWare. Maybe this is all not necessary, since Flojo is working on a pass without flattening.","title":"5. Recreate the original design hierarchy from the flattened netlist"}]}